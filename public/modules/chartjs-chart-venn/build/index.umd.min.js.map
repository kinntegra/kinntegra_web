{"version":3,"file":"index.umd.min.js","sources":["../src/model/interfaces.ts","../src/model/math.ts","../src/elements/ArcSlice.ts","../src/model/generateArcSlicePath.ts","../src/controllers/patchController.ts","../src/controllers/VennDiagramController.ts","../src/model/layout.ts","../.yarn/cache/fmin-npm-0.0.2-8396d465c7-c65de531d0.zip/node_modules/fmin/build/fmin.js","../.yarn/cache/@upsetjs-venn.js-npm-1.4.1-2b75ff58e7-2449480826.zip/node_modules/@upsetjs/venn.js/build/venn.esm.js","../src/model/euler.ts","../src/controllers/EulerDiagramController.ts","../src/data.ts","../src/index.umd.ts"],"sourcesContent":[null,null,null,null,null,null,null,"(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (factory((global.fmin = global.fmin || {})));\n}(this, function (exports) { 'use strict';\n\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */\n    function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100,\n            tolerance = parameters.tolerance || 1e-10,\n            fA = f(a),\n            fB = f(b),\n            delta = b - a;\n\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n\n        for (var i = 0; i < maxIterations; ++i) {\n            delta /= 2;\n            var mid = a + delta,\n                fMid = f(mid);\n\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\n    function dot(a, b) {\n        var ret = 0;\n        for (var i = 0; i < a.length; ++i) {\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n\n    function norm2(a)  {\n        return Math.sqrt(dot(a, a));\n    }\n\n    function scale(ret, value, c) {\n        for (var i = 0; i < value.length; ++i) {\n            ret[i] = value[i] * c;\n        }\n    }\n\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for (var j = 0; j < ret.length; ++j) {\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n\n    /** minimizes a function using the downhill simplex method */\n    function nelderMead(f, x0, parameters) {\n        parameters = parameters || {};\n\n        var maxIterations = parameters.maxIterations || x0.length * 200,\n            nonZeroDelta = parameters.nonZeroDelta || 1.05,\n            zeroDelta = parameters.zeroDelta || 0.001,\n            minErrorDelta = parameters.minErrorDelta || 1e-6,\n            minTolerance = parameters.minErrorDelta || 1e-5,\n            rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n            chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n            psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n            sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n            maxDiff;\n\n        // initialize simplex.\n        var N = x0.length,\n            simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        simplex[0].id = 0;\n        for (var i = 0; i < N; ++i) {\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i+1] = point;\n            simplex[i+1].fx = f(point);\n            simplex[i+1].id = i+1;\n        }\n\n        function updateSimplex(value) {\n            for (var i = 0; i < value.length; i++) {\n                simplex[N][i] = value[i];\n            }\n            simplex[N].fx = value.fx;\n        }\n\n        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n        var centroid = x0.slice(),\n            reflected = x0.slice(),\n            contracted = x0.slice(),\n            expanded = x0.slice();\n\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n            simplex.sort(sortOrder);\n\n            if (parameters.history) {\n                // copy the simplex (since later iterations will mutate) and\n                // sort it to have a consistent order between iterations\n                var sortedSimplex = simplex.map(function (x) {\n                    var state = x.slice();\n                    state.fx = x.fx;\n                    state.id = x.id;\n                    return state;\n                });\n                sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n                parameters.history.push({x: simplex[0].slice(),\n                                         fx: simplex[0].fx,\n                                         simplex: sortedSimplex});\n            }\n\n            maxDiff = 0;\n            for (i = 0; i < N; ++i) {\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n                (maxDiff < minTolerance)) {\n                break;\n            }\n\n            // compute the centroid of all but the worst point in the simplex\n            for (i = 0; i < N; ++i) {\n                centroid[i] = 0;\n                for (var j = 0; j < N; ++j) {\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx < simplex[0].fx) {\n                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    updateSimplex(expanded);\n                }  else {\n                    updateSimplex(reflected);\n                }\n            }\n\n            // if the reflected point is worse than the second worst, we need to\n            // contract\n            else if (reflected.fx >= simplex[N-1].fx) {\n                var shouldReduce = false;\n\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < reflected.fx) {\n                        updateSimplex(contracted);\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n\n                if (shouldReduce) {\n                    // if we don't contract here, we're done\n                    if (sigma >= 1) break;\n\n                    // do a reduction\n                    for (i = 1; i < simplex.length; ++i) {\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                updateSimplex(reflected);\n            }\n        }\n\n        simplex.sort(sortOrder);\n        return {fx : simplex[0].fx,\n                x : simplex[0]};\n    }\n\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    /// f : objective function\n    /// pk : search direction\n    /// current: object containing current gradient/loss\n    /// next: output: contains next gradient/loss\n    /// returns a: step size taken\n    function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n            phi = phi0, phi_old = phi0,\n            phiPrime = phiPrime0,\n            a0 = 0;\n\n        a = a || 1;\n        c1 = c1 || 1e-6;\n        c2 = c2 || 0.1;\n\n        function zoom(a_lo, a_high, phi_lo) {\n            for (var iteration = 0; iteration < 16; ++iteration) {\n                a = (a_lo + a_high)/2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                    (phi >= phi_lo)) {\n                    a_high = a;\n\n                } else  {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n\n                    if (phiPrime * (a_high - a_lo) >=0) {\n                        a_high = a_lo;\n                    }\n\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n\n            return 0;\n        }\n\n        for (var iteration = 0; iteration < 10; ++iteration) {\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (iteration && (phi >= phi_old))) {\n                return zoom(a0, a, phi_old);\n            }\n\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n\n            if (phiPrime >= 0 ) {\n                return zoom(a, a0, phi);\n            }\n\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n\n        return a;\n    }\n\n    function conjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            yk = initial.slice(),\n            pk, temp,\n            a = 1,\n            maxIterations;\n\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 20;\n\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        scale(pk, current.fxprime,-1);\n\n        for (var i = 0; i < maxIterations; ++i) {\n            a = wolfeLineSearch(f, pk, current, next, a);\n\n            // todo: history in wrong spot?\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     alpha: a});\n            }\n\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                scale(pk, current.fxprime, -1);\n\n            } else {\n                // update direction using Polak–Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n                var delta_k = dot(current.fxprime, current.fxprime),\n                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n                temp = current;\n                current = next;\n                next = temp;\n            }\n\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        return current;\n    }\n\n    function gradientDescent(f, initial, params) {\n        params = params || {};\n        var maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 0.001,\n            current = {x: initial.slice(), fx: 0, fxprime: initial.slice()};\n\n        for (var i = 0; i < maxIterations; ++i) {\n            current.fx = f(current.x, current.fxprime);\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice()});\n            }\n\n            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        return current;\n    }\n\n    function gradientDescentLineSearch(f, initial, params) {\n        params = params || {};\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            maxIterations = params.maxIterations || initial.length * 100,\n            learnRate = params.learnRate || 1,\n            pk = initial.slice(),\n            c1 = params.c1 || 1e-3,\n            c2 = params.c2 || 0.1,\n            temp,\n            functionCalls = [];\n\n        if (params.history) {\n            // wrap the function call to track linesearch samples\n            var inner = f;\n            f = function(x, fxprime) {\n                functionCalls.push(x.slice());\n                return inner(x, fxprime);\n            };\n        }\n\n        current.fx = f(current.x, current.fxprime);\n        for (var i = 0; i < maxIterations; ++i) {\n            scale(pk, current.fxprime, -1);\n            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c2);\n\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice(),\n                                     functionCalls: functionCalls,\n                                     learnRate: learnRate,\n                                     alpha: learnRate});\n                functionCalls = [];\n            }\n\n\n            temp = current;\n            current = next;\n            next = temp;\n\n            if ((learnRate === 0) || (norm2(current.fxprime) < 1e-5)) break;\n        }\n\n        return current;\n    }\n\n    exports.bisect = bisect;\n    exports.nelderMead = nelderMead;\n    exports.conjugateGradient = conjugateGradient;\n    exports.gradientDescent = gradientDescent;\n    exports.gradientDescentLineSearch = gradientDescentLineSearch;\n    exports.zeros = zeros;\n    exports.zerosM = zerosM;\n    exports.norm2 = norm2;\n    exports.weightedSum = weightedSum;\n    exports.scale = scale;\n\n}));","import { nelderMead, bisect, norm2, zeros, conjugateGradient, scale, zerosM } from 'fmin';\n\nconst SMALL = 1e-10;\n\n/**\n * Returns the intersection area of a bunch of circles (where each circle\n * is an object having an x,y and radius property)\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @param {undefined | { area?: number, arcArea?: number, polygonArea?: number, arcs?: ReadonlyArray<{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }>, innerPoints: ReadonlyArray<{\n    x: number;\n    y: number;\n    parentIndex: [number, number];\n}>, intersectionPoints: ReadonlyArray<{\n  x: number;\n  y: number;\n  parentIndex: [number, number];\n}> }} stats\n * @returns {number}\n */\nfunction intersectionArea(circles, stats) {\n  // get all the intersection points of the circles\n  const intersectionPoints = getIntersectionPoints(circles);\n\n  // filter out points that aren't included in all the circles\n  const innerPoints = intersectionPoints.filter((p) => containedInCircles(p, circles));\n\n  let arcArea = 0;\n  let polygonArea = 0;\n  /** @type {{ circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} }[]} */\n  const arcs = [];\n\n  // if we have intersection points that are within all the circles,\n  // then figure out the area contained by them\n  if (innerPoints.length > 1) {\n    // sort the points by angle from the center of the polygon, which lets\n    // us just iterate over points to get the edges\n    const center = getCenter(innerPoints);\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p = innerPoints[i];\n      p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n    }\n    innerPoints.sort((a, b) => b.angle - a.angle);\n\n    // iterate over all points, get arc between the points\n    // and update the areas\n    let p2 = innerPoints[innerPoints.length - 1];\n    for (let i = 0; i < innerPoints.length; ++i) {\n      const p1 = innerPoints[i];\n\n      // polygon area updates easily ...\n      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n      // updating the arc area is a little more involved\n      const midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };\n      /** @types null | { circle: {x: number, y: number, radius: number}, width: number, p1: {x: number, y: number}, p2: {x: number, y: number} } */\n      let arc = null;\n\n      for (let j = 0; j < p1.parentIndex.length; ++j) {\n        if (p2.parentIndex.includes(p1.parentIndex[j])) {\n          // figure out the angle halfway between the two points\n          // on the current circle\n          const circle = circles[p1.parentIndex[j]];\n          const a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y);\n          const a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n          let angleDiff = a2 - a1;\n          if (angleDiff < 0) {\n            angleDiff += 2 * Math.PI;\n          }\n\n          // and use that angle to figure out the width of the\n          // arc\n          const a = a2 - angleDiff / 2;\n          let width = distance(midPoint, {\n            x: circle.x + circle.radius * Math.sin(a),\n            y: circle.y + circle.radius * Math.cos(a),\n          });\n\n          // clamp the width to the largest is can actually be\n          // (sometimes slightly overflows because of FP errors)\n          if (width > circle.radius * 2) {\n            width = circle.radius * 2;\n          }\n\n          // pick the circle whose arc has the smallest width\n          if (arc == null || arc.width > width) {\n            arc = { circle, width, p1, p2, large: width > circle.radius, sweep: true };\n          }\n        }\n      }\n\n      if (arc != null) {\n        arcs.push(arc);\n        arcArea += circleArea(arc.circle.radius, arc.width);\n        p2 = p1;\n      }\n    }\n  } else {\n    // no intersection points, is either disjoint - or is completely\n    // overlapped. figure out which by examining the smallest circle\n    let smallest = circles[0];\n    for (let i = 1; i < circles.length; ++i) {\n      if (circles[i].radius < smallest.radius) {\n        smallest = circles[i];\n      }\n    }\n\n    // make sure the smallest circle is completely contained in all\n    // the other circles\n    let disjoint = false;\n    for (let i = 0; i < circles.length; ++i) {\n      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n        disjoint = true;\n        break;\n      }\n    }\n\n    if (disjoint) {\n      arcArea = polygonArea = 0;\n    } else {\n      arcArea = smallest.radius * smallest.radius * Math.PI;\n      arcs.push({\n        circle: smallest,\n        p1: { x: smallest.x, y: smallest.y + smallest.radius },\n        p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },\n        width: smallest.radius * 2,\n        large: true,\n        sweep: true,\n      });\n    }\n  }\n\n  polygonArea /= 2;\n\n  if (stats) {\n    stats.area = arcArea + polygonArea;\n    stats.arcArea = arcArea;\n    stats.polygonArea = polygonArea;\n    stats.arcs = arcs;\n    stats.innerPoints = innerPoints;\n    stats.intersectionPoints = intersectionPoints;\n  }\n\n  return arcArea + polygonArea;\n}\n\n/**\n * returns whether a point is contained by all of a list of circles\n * @param {{x: number, y: number}} point\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {boolean}\n */\nfunction containedInCircles(point, circles) {\n  return circles.every((circle) => distance(point, circle) < circle.radius + SMALL);\n}\n\n/**\n * Gets all intersection points between a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {ReadonlyArray<{x: number, y: number, parentIndex: [number, number]}>}\n */\nfunction getIntersectionPoints(circles) {\n  /** @type {{x: number, y: number, parentIndex: [number, number]}[]} */\n  const ret = [];\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const intersect = circleCircleIntersection(circles[i], circles[j]);\n      for (const p of intersect) {\n        p.parentIndex = [i, j];\n        ret.push(p);\n      }\n    }\n  }\n  return ret;\n}\n\n/**\n * Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html\n * @param {number} r\n * @param {number} width\n * @returns {number}\n **/\nfunction circleArea(r, width) {\n  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/**\n * euclidean distance between two points\n * @param {{x: number, y: number}} p1\n * @param {{x: number, y: number}} p2\n * @returns {number}\n **/\nfunction distance(p1, p2) {\n  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n/**\n * Returns the overlap area of two circles of radius r1 and r2 - that\n * have their centers separated by distance d. Simpler faster\n * circle intersection for only two circles\n * @param {number} r1\n * @param {number} r2\n * @param {number} d\n * @returns {number}\n */\nfunction circleOverlap(r1, r2, d) {\n  // no overlap\n  if (d >= r1 + r2) {\n    return 0;\n  }\n\n  // completely overlapped\n  if (d <= Math.abs(r1 - r2)) {\n    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n  }\n\n  const w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d);\n  const w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n  return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/**\n * Given two circles (containing a x/y/radius attributes),\n * returns the intersecting points if possible\n * note: doesn't handle cases where there are infinitely many\n * intersection points (circles are equivalent):, or only one intersection point\n * @param {{x: number, y: number, radius: number}} p1\n * @param {{x: number, y: number, radius: number}} p2\n * @returns {ReadonlyArray<{x: number, y: number}>}\n **/\nfunction circleCircleIntersection(p1, p2) {\n  const d = distance(p1, p2);\n  const r1 = p1.radius;\n  const r2 = p2.radius;\n\n  // if to far away, or self contained - can't be done\n  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n    return [];\n  }\n\n  const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);\n  const h = Math.sqrt(r1 * r1 - a * a);\n  const x0 = p1.x + (a * (p2.x - p1.x)) / d;\n  const y0 = p1.y + (a * (p2.y - p1.y)) / d;\n  const rx = -(p2.y - p1.y) * (h / d);\n  const ry = -(p2.x - p1.x) * (h / d);\n\n  return [\n    { x: x0 + rx, y: y0 - ry },\n    { x: x0 - rx, y: y0 + ry },\n  ];\n}\n\n/**\n * Returns the center of a bunch of points\n * @param {ReadonlyArray<{x: number, y: number}>} points\n * @returns {{x: number, y: number}}\n */\nfunction getCenter(points) {\n  const center = { x: 0, y: 0 };\n  for (const point of points) {\n    center.x += point.x;\n    center.y += point.y;\n  }\n  center.x /= points.length;\n  center.y /= points.length;\n  return center;\n}\n\n/**\n * given a list of set objects, and their corresponding overlaps\n * updates the (x, y, radius) attribute on each set such that their positions\n * roughly correspond to the desired overlaps\n * @param {readonly {sets: readonly string[]; size: number; weight?: number}[]} sets\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction venn(sets, parameters = {}) {\n  parameters.maxIterations = parameters.maxIterations || 500;\n\n  const initialLayout = parameters.initialLayout || bestInitialLayout;\n  const loss = parameters.lossFunction || lossFunction;\n\n  // add in missing pairwise areas as having 0 size\n  const areas = addMissingAreas(sets, parameters);\n\n  // initial layout is done greedily\n  const circles = initialLayout(areas, parameters);\n\n  // transform x/y coordinates to a vector to optimize\n  const setids = Object.keys(circles);\n  /** @type {number[]} */\n  const initial = [];\n  for (const setid of setids) {\n    initial.push(circles[setid].x);\n    initial.push(circles[setid].y);\n  }\n\n  // optimize initial layout from our loss function\n  const solution = nelderMead(\n    (values) => {\n      const current = {};\n      for (let i = 0; i < setids.length; ++i) {\n        const setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius,\n          // size : circles[setid].size\n        };\n      }\n      return loss(current, areas);\n    },\n    initial,\n    parameters\n  );\n\n  // transform solution vector back to x/y points\n  const positions = solution.x;\n  for (let i = 0; i < setids.length; ++i) {\n    const setid = setids[i];\n    circles[setid].x = positions[2 * i];\n    circles[setid].y = positions[2 * i + 1];\n  }\n\n  return circles;\n}\n\nconst SMALL$1 = 1e-10;\n\n/**\n * Returns the distance necessary for two circles of radius r1 + r2 to\n * have the overlap area 'overlap'\n * @param {number} r1\n * @param {number} r2\n * @param {number} overlap\n * @returns {number}\n */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n  // handle complete overlapped circles\n  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\n    return Math.abs(r1 - r2);\n  }\n\n  return bisect((distance) => circleOverlap(r1, r2, distance) - overlap, 0, r1 + r2);\n}\n\n/**\n * Missing pair-wise intersection area data can cause problems:\n * treating as an unknown means that sets will be laid out overlapping,\n * which isn't what people expect. To reflect that we want disjoint sets\n * here, set the overlap to 0 for all missing pairwise set intersections\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>}\n */\nfunction addMissingAreas(areas, parameters = {}) {\n  const distinct = parameters.distinct;\n  const r = areas.map((s) => Object.assign({}, s));\n\n  function toKey(arr) {\n    return arr.join(';');\n  }\n\n  if (distinct) {\n    // recreate the full ones by adding things up but just to level two since the rest doesn't matter\n    /** @types Map<string, number> */\n    const count = new Map();\n    for (const area of r) {\n      for (let i = 0; i < area.sets.length; i++) {\n        const si = String(area.sets[i]);\n        count.set(si, area.size + (count.get(si) || 0));\n        for (let j = i + 1; j < area.sets.length; j++) {\n          const sj = String(area.sets[j]);\n          const k1 = `${si};${sj}`;\n          const k2 = `${sj};${si}`;\n          count.set(k1, area.size + (count.get(k1) || 0));\n          count.set(k2, area.size + (count.get(k2) || 0));\n        }\n      }\n    }\n    for (const area of r) {\n      if (area.sets.length < 3) {\n        area.size = count.get(toKey(area.sets));\n      }\n    }\n  }\n\n  // two circle intersections that aren't defined\n  const ids = [];\n\n  /** @type {Set<string>} */\n  const pairs = new Set();\n  for (const area of r) {\n    if (area.sets.length === 1) {\n      ids.push(area.sets[0]);\n    } else if (area.sets.length === 2) {\n      const a = area.sets[0];\n      const b = area.sets[1];\n      pairs.add(toKey(area.sets));\n      pairs.add(toKey([b, a]));\n    }\n  }\n\n  ids.sort((a, b) => (a === b ? 0 : a < b ? -1 : +1));\n\n  for (let i = 0; i < ids.length; ++i) {\n    const a = ids[i];\n    for (let j = i + 1; j < ids.length; ++j) {\n      const b = ids[j];\n      if (!pairs.has(toKey([a, b]))) {\n        r.push({ sets: [a, b], size: 0 });\n      }\n    }\n  }\n  return r;\n}\n\n/**\n * Returns two matrices, one of the euclidean distances between the sets\n * and the other indicating if there are subset or disjoint set relationships\n * @param {ReadonlyArray<{sets: ReadonlyArray<number>}>} areas\n * @param {ReadonlyArray<{size: number}>} sets\n * @param {ReadonlyArray<number>} setids\n */\nfunction getDistanceMatrices(areas, sets, setids) {\n  // initialize an empty distance matrix between all the points\n  /**\n   * @type {number[][]}\n   */\n  const distances = zerosM(sets.length, sets.length);\n  /**\n   * @type {number[][]}\n   */\n  const constraints = zerosM(sets.length, sets.length);\n\n  // compute required distances between all the sets such that\n  // the areas match\n  areas\n    .filter((x) => x.sets.length === 2)\n    .forEach((current) => {\n      const left = setids[current.sets[0]];\n      const right = setids[current.sets[1]];\n      const r1 = Math.sqrt(sets[left].size / Math.PI);\n      const r2 = Math.sqrt(sets[right].size / Math.PI);\n      const distance = distanceFromIntersectArea(r1, r2, current.size);\n\n      distances[left][right] = distances[right][left] = distance;\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      let c = 0;\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n      constraints[left][right] = constraints[right][left] = c;\n    });\n\n  return { distances, constraints };\n}\n\n/// computes the gradient and loss simultaneously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n  for (let i = 0; i < fxprime.length; ++i) {\n    fxprime[i] = 0;\n  }\n\n  let loss = 0;\n  for (let i = 0; i < distances.length; ++i) {\n    const xi = x[2 * i];\n    const yi = x[2 * i + 1];\n    for (let j = i + 1; j < distances.length; ++j) {\n      const xj = x[2 * j];\n      const yj = x[2 * j + 1];\n      const dij = distances[i][j];\n      const constraint = constraints[i][j];\n\n      const squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi);\n      const distance = Math.sqrt(squaredDistance);\n      const delta = squaredDistance - dij * dij;\n\n      if ((constraint > 0 && distance <= dij) || (constraint < 0 && distance >= dij)) {\n        continue;\n      }\n\n      loss += 2 * delta * delta;\n\n      fxprime[2 * i] += 4 * delta * (xi - xj);\n      fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n\n      fxprime[2 * j] += 4 * delta * (xj - xi);\n      fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n    }\n  }\n  return loss;\n}\n\n/**\n * takes the best working variant of either constrained MDS or greedy\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n */\nfunction bestInitialLayout(areas, params = {}) {\n  let initial = greedyLayout(areas, params);\n  const loss = params.lossFunction || lossFunction;\n\n  // greedylayout is sufficient for all 2/3 circle cases. try out\n  // constrained MDS for higher order problems, take its output\n  // if it outperforms. (greedy is aesthetically better on 2/3 circles\n  // since it axis aligns)\n  if (areas.length >= 8) {\n    const constrained = constrainedMDSLayout(areas, params);\n    const constrainedLoss = loss(constrained, areas);\n    const greedyLoss = loss(initial, areas);\n\n    if (constrainedLoss + 1e-8 < greedyLoss) {\n      initial = constrained;\n    }\n  }\n  return initial;\n}\n\n/**\n * use the constrained MDS variant to generate an initial layout\n * @param {ReadonlyArray<{sets: ReadonlyArray<string>, size: number}>} areas\n * @returns {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction constrainedMDSLayout(areas, params = {}) {\n  const restarts = params.restarts || 10;\n\n  // bidirectionally map sets to a rowid  (so we can create a matrix)\n  const sets = [];\n  const setids = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      setids[area.sets[0]] = sets.length;\n      sets.push(area);\n    }\n  }\n\n  let { distances, constraints } = getDistanceMatrices(areas, sets, setids);\n\n  // keep distances bounded, things get messed up otherwise.\n  // TODO: proper preconditioner?\n  const norm = norm2(distances.map(norm2)) / distances.length;\n  distances = distances.map((row) => row.map((value) => value / norm));\n\n  const obj = (x, fxprime) => constrainedMDSGradient(x, fxprime, distances, constraints);\n\n  let best = null;\n  for (let i = 0; i < restarts; ++i) {\n    const initial = zeros(distances.length * 2).map(Math.random);\n\n    const current = conjugateGradient(obj, initial, params);\n    if (!best || current.fx < best.fx) {\n      best = current;\n    }\n  }\n\n  const positions = best.x;\n\n  // translate rows back to (x,y,radius) coordinates\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  for (let i = 0; i < sets.length; ++i) {\n    const set = sets[i];\n    circles[set.sets[0]] = {\n      x: positions[2 * i] * norm,\n      y: positions[2 * i + 1] * norm,\n      radius: Math.sqrt(set.size / Math.PI),\n    };\n  }\n\n  if (params.history) {\n    for (const h of params.history) {\n      scale(h.x, norm);\n    }\n  }\n  return circles;\n}\n\n/**\n * Lays out a Venn diagram greedily, going from most overlapped sets to\n * least overlapped, attempting to position each new set such that the\n * overlapping areas to already positioned sets are basically right\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>}>} areas\n * @return {{[key: string]: {x: number, y: number, radius: number}}}\n */\nfunction greedyLayout(areas, params) {\n  const loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n\n  // define a circle for each set\n  /** @type {{[key: string]: {x: number, y: number, radius: number}}} */\n  const circles = {};\n  /** @type {{[key: string]: {set: string, size: number, weight: number}[]}} */\n  const setOverlaps = {};\n  for (const area of areas) {\n    if (area.sets.length === 1) {\n      const set = area.sets[0];\n      circles[set] = {\n        x: 1e10,\n        y: 1e10,\n        rowid: circles.length,\n        size: area.size,\n        radius: Math.sqrt(area.size / Math.PI),\n      };\n      setOverlaps[set] = [];\n    }\n  }\n\n  areas = areas.filter((a) => a.sets.length === 2);\n\n  // map each set to a list of all the other sets that overlap it\n  for (const current of areas) {\n    let weight = current.weight != null ? current.weight : 1.0;\n    const left = current.sets[0];\n    const right = current.sets[1];\n\n    // completely overlapped circles shouldn't be positioned early here\n    if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {\n      weight = 0;\n    }\n\n    setOverlaps[left].push({ set: right, size: current.size, weight });\n    setOverlaps[right].push({ set: left, size: current.size, weight });\n  }\n\n  // get list of most overlapped sets\n  const mostOverlapped = [];\n  Object.keys(setOverlaps).forEach((set) => {\n    let size = 0;\n    for (let i = 0; i < setOverlaps[set].length; ++i) {\n      size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n    }\n\n    mostOverlapped.push({ set, size });\n  });\n\n  // sort by size desc\n  function sortOrder(a, b) {\n    return b.size - a.size;\n  }\n  mostOverlapped.sort(sortOrder);\n\n  // keep track of what sets have been laid out\n  const positioned = {};\n  function isPositioned(element) {\n    return element.set in positioned;\n  }\n\n  /**\n   * adds a point to the output\n   * @param {{x: number, y: number}} point\n   * @param {number} index\n   */\n  function positionSet(point, index) {\n    circles[index].x = point.x;\n    circles[index].y = point.y;\n    positioned[index] = true;\n  }\n\n  // add most overlapped set at (0,0)\n  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);\n\n  // get distances between all points. TODO, necessary?\n  // answer: probably not\n  // var distances = venn.getDistanceMatrices(circles, areas).distances;\n  for (let i = 1; i < mostOverlapped.length; ++i) {\n    const setIndex = mostOverlapped[i].set;\n    const overlap = setOverlaps[setIndex].filter(isPositioned);\n    const set = circles[setIndex];\n    overlap.sort(sortOrder);\n\n    if (overlap.length === 0) {\n      // this shouldn't happen anymore with addMissingAreas\n      throw 'ERROR: missing pairwise overlap information';\n    }\n\n    /** @type {{x: number, y: number}[]} */\n    const points = [];\n    for (var j = 0; j < overlap.length; ++j) {\n      // get appropriate distance from most overlapped already added set\n      const p1 = circles[overlap[j].set];\n      const d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n      // sample positions at 90 degrees for maximum aesthetics\n      points.push({ x: p1.x + d1, y: p1.y });\n      points.push({ x: p1.x - d1, y: p1.y });\n      points.push({ y: p1.y + d1, x: p1.x });\n      points.push({ y: p1.y - d1, x: p1.x });\n\n      // if we have at least 2 overlaps, then figure out where the\n      // set should be positioned analytically and try those too\n      for (let k = j + 1; k < overlap.length; ++k) {\n        const p2 = circles[overlap[k].set];\n        const d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n\n        const extraPoints = circleCircleIntersection(\n          { x: p1.x, y: p1.y, radius: d1 },\n          { x: p2.x, y: p2.y, radius: d2 }\n        );\n        points.push(...extraPoints);\n      }\n    }\n\n    // we have some candidate positions for the set, examine loss\n    // at each position to figure out where to put it at\n    let bestLoss = 1e50;\n    let bestPoint = points[0];\n    for (const point of points) {\n      circles[setIndex].x = point.x;\n      circles[setIndex].y = point.y;\n      const localLoss = loss(circles, areas);\n      if (localLoss < bestLoss) {\n        bestLoss = localLoss;\n        bestPoint = point;\n      }\n    }\n\n    positionSet(bestPoint, setIndex);\n  }\n\n  return circles;\n}\n\n/**\n * Given a bunch of sets, and the desired overlaps between these sets - computes\n * the distance from the actual overlaps to the desired overlaps. Note that\n * this method ignores overlaps of more than 2 circles\n * @param {{[key: string]: <{x: number, y: number, radius: number}>}} circles\n * @param {ReadonlyArray<{size: number, sets: ReadonlyArray<string>, weight?: number}>} overlaps\n * @returns {number}\n */\nfunction lossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    output += weight * (overlap - area.size) * (overlap - area.size);\n  }\n\n  return output;\n}\n\nfunction logRatioLossFunction(circles, overlaps) {\n  let output = 0;\n\n  for (const area of overlaps) {\n    if (area.sets.length === 1) {\n      continue;\n    }\n    /** @type {number} */\n    let overlap;\n    if (area.sets.length === 2) {\n      const left = circles[area.sets[0]];\n      const right = circles[area.sets[1]];\n      overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n    } else {\n      overlap = intersectionArea(area.sets.map((d) => circles[d]));\n    }\n\n    const weight = area.weight != null ? area.weight : 1.0;\n    const differenceFromIdeal = Math.log((overlap + 1) / (area.size + 1));\n    output += weight * differenceFromIdeal * differenceFromIdeal;\n  }\n\n  return output;\n}\n\n/**\n * orientates a bunch of circles to point in orientation\n * @param {{x :number, y: number, radius: number}[]} circles\n * @param {number | undefined} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n */\nfunction orientateCircles(circles, orientation, orientationOrder) {\n  if (orientationOrder == null) {\n    circles.sort((a, b) => b.radius - a.radius);\n  } else {\n    circles.sort(orientationOrder);\n  }\n\n  // shift circles so largest circle is at (0, 0)\n  if (circles.length > 0) {\n    const largestX = circles[0].x;\n    const largestY = circles[0].y;\n\n    for (const circle of circles) {\n      circle.x -= largestX;\n      circle.y -= largestY;\n    }\n  }\n\n  if (circles.length === 2) {\n    // if the second circle is a subset of the first, arrange so that\n    // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n    const dist = distance(circles[0], circles[1]);\n    if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n      circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n      circles[1].y = circles[0].y;\n    }\n  }\n\n  // rotate circles so that second largest is at an angle of 'orientation'\n  // from largest\n  if (circles.length > 1) {\n    const rotation = Math.atan2(circles[1].x, circles[1].y) - orientation;\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n\n    for (const circle of circles) {\n      const x = circle.x;\n      const y = circle.y;\n      circle.x = c * x - s * y;\n      circle.y = s * x + c * y;\n    }\n  }\n\n  // mirror solution if third solution is above plane specified by\n  // first two circles\n  if (circles.length > 2) {\n    let angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n    while (angle < 0) {\n      angle += 2 * Math.PI;\n    }\n    while (angle > 2 * Math.PI) {\n      angle -= 2 * Math.PI;\n    }\n    if (angle > Math.PI) {\n      const slope = circles[1].y / (1e-10 + circles[1].x);\n      for (const circle of circles) {\n        var d = (circle.x + slope * circle.y) / (1 + slope * slope);\n        circle.x = 2 * d - circle.x;\n        circle.y = 2 * d * slope - circle.y;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {{x: number, y: number, radius: number}[][]}\n */\nfunction disjointCluster(circles) {\n  // union-find clustering to get disjoint sets\n  circles.forEach((circle) => {\n    circle.parent = circle;\n  });\n\n  // path compression step in union find\n  function find(circle) {\n    if (circle.parent !== circle) {\n      circle.parent = find(circle.parent);\n    }\n    return circle.parent;\n  }\n\n  function union(x, y) {\n    const xRoot = find(x);\n    const yRoot = find(y);\n    xRoot.parent = yRoot;\n  }\n\n  // get the union of all overlapping sets\n  for (let i = 0; i < circles.length; ++i) {\n    for (let j = i + 1; j < circles.length; ++j) {\n      const maxDistance = circles[i].radius + circles[j].radius;\n      if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n        union(circles[j], circles[i]);\n      }\n    }\n  }\n\n  // find all the disjoint clusters and group them together\n  /** @type {Map<string, {x: number, y: number, radius: number}[]>} */\n  const disjointClusters = new Map();\n  for (let i = 0; i < circles.length; ++i) {\n    const setid = find(circles[i]).parent.setid;\n    if (!disjointClusters.has(setid)) {\n      disjointClusters.set(setid, []);\n    }\n    disjointClusters.get(setid).push(circles[i]);\n  }\n\n  // cleanup bookkeeping\n  circles.forEach((circle) => {\n    delete circle.parent;\n  });\n\n  // return in more usable form\n  return Array.from(disjointClusters.values());\n}\n\n/**\n * @param {ReadonlyArray<{x :number, y: number, radius: number}>} circles\n * @returns {{xRange: [number, number], yRange: [number, number]}}\n */\nfunction getBoundingBox(circles) {\n  const minMax = (d) => {\n    const hi = circles.reduce((acc, c) => Math.max(acc, c[d] + c.radius), Number.NEGATIVE_INFINITY);\n    const lo = circles.reduce((acc, c) => Math.min(acc, c[d] - c.radius), Number.POSITIVE_INFINITY);\n    return { max: hi, min: lo };\n  };\n  return { xRange: minMax('x'), yRange: minMax('y') };\n}\n\n/**\n *\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {undefined | number} orientation\n * @param {((a: {x :number, y: number, radius: number}, b: {x :number, y: number, radius: number}) => number) | undefined} orientationOrder\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n  if (orientation == null) {\n    orientation = Math.PI / 2;\n  }\n\n  // work with a list instead of a dictionary, and take a copy so we\n  // don't mutate input\n  let circles = fromObjectNotation(solution).map((d) => Object.assign({}, d));\n\n  // get all the disjoint clusters\n  const clusters = disjointCluster(circles);\n\n  // orientate all disjoint sets, get sizes\n  for (const cluster of clusters) {\n    orientateCircles(cluster, orientation, orientationOrder);\n    const bounds = getBoundingBox(cluster);\n    cluster.size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n    cluster.bounds = bounds;\n  }\n  clusters.sort((a, b) => b.size - a.size);\n\n  // orientate the largest at 0,0, and get the bounds\n  circles = clusters[0];\n  let returnBounds = circles.bounds;\n  const spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n\n  /**\n   * @param {ReadonlyArray<{x: number, y: number, radius: number, setid: string}>} cluster\n   * @param {boolean} right\n   * @param {boolean} bottom\n   */\n  function addCluster(cluster, right, bottom) {\n    if (!cluster) {\n      return;\n    }\n\n    const bounds = cluster.bounds;\n    /** @type {number} */\n    let xOffset;\n    /** @type {number} */\n    let yOffset;\n\n    if (right) {\n      xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n    } else {\n      xOffset = returnBounds.xRange.max - bounds.xRange.max;\n      const centreing =\n        (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n      if (centreing < 0) {\n        xOffset += centreing;\n      }\n    }\n\n    if (bottom) {\n      yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n    } else {\n      yOffset = returnBounds.yRange.max - bounds.yRange.max;\n      const centreing =\n        (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n      if (centreing < 0) {\n        yOffset += centreing;\n      }\n    }\n\n    for (const c of cluster) {\n      c.x += xOffset;\n      c.y += yOffset;\n      circles.push(c);\n    }\n  }\n\n  let index = 1;\n  while (index < clusters.length) {\n    addCluster(clusters[index], true, false);\n    addCluster(clusters[index + 1], false, true);\n    addCluster(clusters[index + 2], true, true);\n    index += 3;\n\n    // have one cluster (in top left). lay out next three relative\n    // to it in a grid\n    returnBounds = getBoundingBox(circles);\n  }\n\n  // convert back to solution form\n  return toObjectNotation(circles);\n}\n\n/**\n * Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n * a rectangle of width/height - with padding around the borders. also\n * centers the diagram in the available space at the same time.\n * If the scale parameter is not null, this automatic scaling is ignored in favor of this custom one\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @param {number} width\n * @param {number} height\n * @param {number} padding\n * @param {boolean} scaleToFit\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction scaleSolution(solution, width, height, padding, scaleToFit) {\n  const circles = fromObjectNotation(solution);\n\n  width -= 2 * padding;\n  height -= 2 * padding;\n\n  const { xRange, yRange } = getBoundingBox(circles);\n\n  if (xRange.max === xRange.min || yRange.max === yRange.min) {\n    console.log('not scaling solution: zero size detected');\n    return solution;\n  }\n\n  /** @type {number} */\n  let xScaling;\n  /** @type {number} */\n  let yScaling;\n  if (scaleToFit) {\n    const toScaleDiameter = Math.sqrt(scaleToFit / Math.PI) * 2;\n    xScaling = width / toScaleDiameter;\n    yScaling = height / toScaleDiameter;\n  } else {\n    xScaling = width / (xRange.max - xRange.min);\n    yScaling = height / (yRange.max - yRange.min);\n  }\n\n  const scaling = Math.min(yScaling, xScaling);\n  // while we're at it, center the diagram too\n  const xOffset = (width - (xRange.max - xRange.min) * scaling) / 2;\n  const yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n  return toObjectNotation(\n    circles.map((circle) => ({\n      radius: scaling * circle.radius,\n      x: padding + xOffset + (circle.x - xRange.min) * scaling,\n      y: padding + yOffset + (circle.y - yRange.min) * scaling,\n      setid: circle.setid,\n    }))\n  );\n}\n\n/**\n * @param {readonly {x: number, y: number, radius: number, setid: string}[]} circles\n * @returns {{[setid: string]: {x: number, y: number, radius: number}}}\n */\nfunction toObjectNotation(circles) {\n  /** @type {{[setid: string]: {x: number, y: number, radius: number}}} */\n  const r = {};\n  for (const circle of circles) {\n    r[circle.setid] = circle;\n  }\n  return r;\n}\n/**\n * @param {{[setid: string]: {x: number, y: number, radius: number}}} solution\n * @returns {{x: number, y: number, radius: number, setid: string}[]}}\n */\nfunction fromObjectNotation(solution) {\n  const setids = Object.keys(solution);\n  return setids.map((id) => Object.assign(solution[id], { setid: id }));\n}\n\n/*global console:true*/\n\n/**\n * VennDiagram includes an optional `options` parameter containing the following option(s):\n *\n * `colourScheme: Array<String>`\n * A list of color values to be applied when coloring diagram circles.\n *\n * `symmetricalTextCentre: Boolean`\n * Whether to symmetrically center each circle's text horizontally and vertically.\n * Defaults to `false`.\n *\n * `textFill: String`\n * The color to be applied to the text within each circle.\n *\n * @param {object} options\n */\nfunction VennDiagram(options = {}) {\n  let useViewBox = false,\n    width = 600,\n    height = 350,\n    padding = 15,\n    duration = 1000,\n    orientation = Math.PI / 2,\n    normalize = true,\n    scaleToFit = null,\n    wrap = true,\n    styled = true,\n    fontSize = null,\n    orientationOrder = null,\n    distinct = false,\n    round = null,\n    symmetricalTextCentre = options && options.symmetricalTextCentre ? options.symmetricalTextCentre : false,\n    // mimic the behaviour of d3.scale.category10 from the previous\n    // version of d3\n    colourMap = {},\n    // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n    // since we can support older versions of d3 as long as we don't force this,\n    // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n    colourScheme =\n      options && options.colourScheme\n        ? options.colourScheme\n        : options && options.colorScheme\n        ? options.colorScheme\n        : [\n            '#1f77b4',\n            '#ff7f0e',\n            '#2ca02c',\n            '#d62728',\n            '#9467bd',\n            '#8c564b',\n            '#e377c2',\n            '#7f7f7f',\n            '#bcbd22',\n            '#17becf',\n          ],\n    colourIndex = 0,\n    colours = function (key) {\n      if (key in colourMap) {\n        return colourMap[key];\n      }\n      var ret = (colourMap[key] = colourScheme[colourIndex]);\n      colourIndex += 1;\n      if (colourIndex >= colourScheme.length) {\n        colourIndex = 0;\n      }\n      return ret;\n    },\n    layoutFunction = venn,\n    loss = lossFunction;\n\n  function chart(selection) {\n    let data = selection.datum();\n\n    // handle 0-sized sets by removing from input\n    const toRemove = new Set();\n    data.forEach((datum) => {\n      if (datum.size == 0 && datum.sets.length == 1) {\n        toRemove.add(datum.sets[0]);\n      }\n    });\n    data = data.filter((datum) => !datum.sets.some((set) => toRemove.has(set)));\n\n    let circles = {};\n    let textCentres = {};\n\n    if (data.length > 0) {\n      let solution = layoutFunction(data, { lossFunction: loss, distinct });\n\n      if (normalize) {\n        solution = normalizeSolution(solution, orientation, orientationOrder);\n      }\n\n      circles = scaleSolution(solution, width, height, padding, scaleToFit);\n      textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n    }\n\n    // Figure out the current label for each set. These can change\n    // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n    const labels = {};\n    data.forEach((datum) => {\n      if (datum.label) {\n        labels[datum.sets] = datum.label;\n      }\n    });\n\n    function label(d) {\n      if (d.sets in labels) {\n        return labels[d.sets];\n      }\n      if (d.sets.length == 1) {\n        return '' + d.sets[0];\n      }\n    }\n\n    // create svg if not already existing\n    selection.selectAll('svg').data([circles]).enter().append('svg');\n\n    const svg = selection.select('svg');\n\n    if (useViewBox) {\n      svg.attr('viewBox', `0 0 ${width} ${height}`);\n    } else {\n      svg.attr('width', width).attr('height', height);\n    }\n\n    // to properly transition intersection areas, we need the\n    // previous circles locations. load from elements\n    const previous = {};\n    let hasPrevious = false;\n    svg.selectAll('.venn-area path').each(function (d) {\n      const path = this.getAttribute('d');\n      if (d.sets.length == 1 && path && !distinct) {\n        hasPrevious = true;\n        previous[d.sets[0]] = circleFromPath(path);\n      }\n    });\n    // interpolate intersection area paths between previous and\n    // current paths\n    function pathTween(d) {\n      return (t) => {\n        const c = d.sets.map((set) => {\n          let start = previous[set];\n          let end = circles[set];\n          if (!start) {\n            start = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          if (!end) {\n            end = { x: width / 2, y: height / 2, radius: 1 };\n          }\n          return {\n            x: start.x * (1 - t) + end.x * t,\n            y: start.y * (1 - t) + end.y * t,\n            radius: start.radius * (1 - t) + end.radius * t,\n          };\n        });\n        return intersectionAreaPath(c, round);\n      };\n    }\n\n    // update data, joining on the set ids\n    const nodes = svg.selectAll('.venn-area').data(data, (d) => d.sets);\n\n    // create new nodes\n    const enter = nodes\n      .enter()\n      .append('g')\n      .attr(\n        'class',\n        (d) =>\n          `venn-area venn-${d.sets.length == 1 ? 'circle' : 'intersection'}${\n            d.colour || d.color ? ' venn-coloured' : ''\n          }`\n      )\n      .attr('data-venn-sets', (d) => d.sets.join('_'));\n\n    const enterPath = enter.append('path');\n    const enterText = enter\n      .append('text')\n      .attr('class', 'label')\n      .text((d) => label(d))\n      .attr('text-anchor', 'middle')\n      .attr('dy', '.35em')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // apply minimal style if wanted\n    if (styled) {\n      enterPath\n        .style('fill-opacity', '0')\n        .filter((d) => d.sets.length == 1)\n        .style('fill', (d) => (d.colour ? d.colour : d.color ? d.color : colours(d.sets)))\n        .style('fill-opacity', '.25');\n\n      enterText.style('fill', (d) => {\n        if (d.colour || d.color) {\n          return '#FFF';\n        }\n        if (options.textFill) {\n          return options.textFill;\n        }\n        return d.sets.length == 1 ? colours(d.sets) : '#444';\n      });\n    }\n\n    function asTransition(s) {\n      if (typeof s.transition === 'function') {\n        return s.transition('venn').duration(duration);\n      }\n      return s;\n    }\n\n    // update existing, using pathTween if necessary\n    let update = selection;\n    if (hasPrevious && typeof update.transition === 'function') {\n      update = asTransition(selection);\n      update.selectAll('path').attrTween('d', pathTween);\n    } else {\n      update.selectAll('path').attr('d', (d) => intersectionAreaPath(d.sets.map((set) => circles[set])), round);\n    }\n\n    const updateText = update\n      .selectAll('text')\n      .filter((d) => d.sets in textCentres)\n      .text((d) => label(d))\n      .attr('x', (d) => Math.floor(textCentres[d.sets].x))\n      .attr('y', (d) => Math.floor(textCentres[d.sets].y));\n\n    if (wrap) {\n      if (hasPrevious) {\n        // d3 4.0 uses 'on' for events on transitions,\n        // but d3 3.0 used 'each' instead. switch appropriately\n        if ('on' in updateText) {\n          updateText.on('end', wrapText(circles, label));\n        } else {\n          updateText.each('end', wrapText(circles, label));\n        }\n      } else {\n        updateText.each(wrapText(circles, label));\n      }\n    }\n\n    // remove old\n    const exit = asTransition(nodes.exit()).remove();\n    if (typeof nodes.transition === 'function') {\n      exit.selectAll('path').attrTween('d', pathTween);\n    }\n\n    const exitText = exit\n      .selectAll('text')\n      .attr('x', width / 2)\n      .attr('y', height / 2);\n\n    // if we've been passed a fontSize explicitly, use it to\n    // transition\n    if (fontSize !== null) {\n      enterText.style('font-size', '0px');\n      updateText.style('font-size', fontSize);\n      exitText.style('font-size', '0px');\n    }\n\n    return { circles, textCentres, nodes, enter, update, exit };\n  }\n\n  chart.wrap = function (_) {\n    if (!arguments.length) return wrap;\n    wrap = _;\n    return chart;\n  };\n\n  chart.useViewBox = function () {\n    useViewBox = true;\n    return chart;\n  };\n\n  chart.width = function (_) {\n    if (!arguments.length) return width;\n    width = _;\n    return chart;\n  };\n\n  chart.height = function (_) {\n    if (!arguments.length) return height;\n    height = _;\n    return chart;\n  };\n\n  chart.padding = function (_) {\n    if (!arguments.length) return padding;\n    padding = _;\n    return chart;\n  };\n\n  chart.distinct = function (_) {\n    if (!arguments.length) return distinct;\n    distinct = _;\n    return chart;\n  };\n\n  chart.colours = function (_) {\n    if (!arguments.length) return colours;\n    colours = _;\n    return chart;\n  };\n\n  chart.colors = function (_) {\n    if (!arguments.length) return colors;\n    colours = _;\n    return chart;\n  };\n\n  chart.fontSize = function (_) {\n    if (!arguments.length) return fontSize;\n    fontSize = _;\n    return chart;\n  };\n\n  chart.round = function (_) {\n    if (!arguments.length) return round;\n    round = _;\n    return chart;\n  };\n\n  chart.duration = function (_) {\n    if (!arguments.length) return duration;\n    duration = _;\n    return chart;\n  };\n\n  chart.layoutFunction = function (_) {\n    if (!arguments.length) return layoutFunction;\n    layoutFunction = _;\n    return chart;\n  };\n\n  chart.normalize = function (_) {\n    if (!arguments.length) return normalize;\n    normalize = _;\n    return chart;\n  };\n\n  chart.scaleToFit = function (_) {\n    if (!arguments.length) return scaleToFit;\n    scaleToFit = _;\n    return chart;\n  };\n\n  chart.styled = function (_) {\n    if (!arguments.length) return styled;\n    styled = _;\n    return chart;\n  };\n\n  chart.orientation = function (_) {\n    if (!arguments.length) return orientation;\n    orientation = _;\n    return chart;\n  };\n\n  chart.orientationOrder = function (_) {\n    if (!arguments.length) return orientationOrder;\n    orientationOrder = _;\n    return chart;\n  };\n\n  chart.lossFunction = function (_) {\n    if (!arguments.length) return loss;\n    loss = _ === 'default' ? lossFunction : _ === 'logRatio' ? logRatioLossFunction : _;\n    return chart;\n  };\n\n  return chart;\n}\n\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n  return function (data) {\n    const text = this;\n    const width = circles[data.sets[0]].radius || 50;\n    const label = labeller(data) || '';\n\n    const words = label.split(/\\s+/).reverse();\n    const maxLines = 3;\n    const minChars = (label.length + words.length) / maxLines;\n\n    let word = words.pop();\n    let line = [word];\n    let lineNumber = 0;\n    const lineHeight = 1.1; // ems\n    text.textContent = null; // clear\n    const tspans = [];\n\n    function append(word) {\n      const tspan = text.ownerDocument.createElementNS(text.namespaceURI, 'tspan');\n      tspan.textContent = word;\n      tspans.push(tspan);\n      text.append(tspan);\n      return tspan;\n    }\n    let tspan = append(word);\n\n    while (true) {\n      word = words.pop();\n      if (!word) {\n        break;\n      }\n      line.push(word);\n      const joined = line.join(' ');\n      tspan.textContent = joined;\n      if (joined.length > minChars && tspan.getComputedTextLength() > width) {\n        line.pop();\n        tspan.textContent = line.join(' ');\n        line = [word];\n        tspan = append(word);\n        lineNumber++;\n      }\n    }\n\n    const initial = 0.35 - (lineNumber * lineHeight) / 2;\n    const x = text.getAttribute('x');\n    const y = text.getAttribute('y');\n    tspans.forEach((t, i) => {\n      t.setAttribute('x', x);\n      t.setAttribute('y', y);\n      t.setAttribute('dy', `${initial + i * lineHeight}em`);\n    });\n  };\n}\n\n/**\n *\n * @param {{x: number, y: number}} current\n * @param {ReadonlyArray<{x: number, y: number}>} interior\n * @param {ReadonlyArray<{x: number, y: number}>} exterior\n * @returns {number}\n */\nfunction circleMargin(current, interior, exterior) {\n  let margin = interior[0].radius - distance(interior[0], current);\n\n  for (let i = 1; i < interior.length; ++i) {\n    const m = interior[i].radius - distance(interior[i], current);\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n\n  for (let i = 0; i < exterior.length; ++i) {\n    const m = distance(exterior[i], current) - exterior[i].radius;\n    if (m <= margin) {\n      margin = m;\n    }\n  }\n  return margin;\n}\n\n/**\n * compute the center of some circles by maximizing the margin of\n * the center point relative to the circles (interior) after subtracting\n * nearby circles (exterior)\n * @param {readonly {x: number, y: number, radius: number}[]} interior\n * @param {readonly {x: number, y: number, radius: number}[]} exterior\n * @param {boolean} symmetricalTextCentre\n * @returns {{x:number, y: number}}\n */\nfunction computeTextCentre(interior, exterior, symmetricalTextCentre) {\n  // get an initial estimate by sampling around the interior circles\n  // and taking the point with the biggest margin\n  /** @type {{x: number, y: number}[]} */\n  const points = [];\n  for (const c of interior) {\n    points.push({ x: c.x, y: c.y });\n    points.push({ x: c.x + c.radius / 2, y: c.y });\n    points.push({ x: c.x - c.radius / 2, y: c.y });\n    points.push({ x: c.x, y: c.y + c.radius / 2 });\n    points.push({ x: c.x, y: c.y - c.radius / 2 });\n  }\n\n  let initial = points[0];\n  let margin = circleMargin(points[0], interior, exterior);\n\n  for (let i = 1; i < points.length; ++i) {\n    const m = circleMargin(points[i], interior, exterior);\n    if (m >= margin) {\n      initial = points[i];\n      margin = m;\n    }\n  }\n\n  // maximize the margin numerically\n  const solution = nelderMead(\n    (p) => -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior),\n    [initial.x, initial.y],\n    { maxIterations: 500, minErrorDelta: 1e-10 }\n  ).x;\n\n  const ret = { x: symmetricalTextCentre ? 0 : solution[0], y: solution[1] };\n\n  // check solution, fallback as needed (happens if fully overlapped\n  // etc)\n  let valid = true;\n  for (const i of interior) {\n    if (distance(ret, i) > i.radius) {\n      valid = false;\n      break;\n    }\n  }\n\n  for (const e of exterior) {\n    if (distance(ret, e) < e.radius) {\n      valid = false;\n      break;\n    }\n  }\n  if (valid) {\n    return ret;\n  }\n\n  if (interior.length == 1) {\n    return { x: interior[0].x, y: interior[0].y };\n  }\n  const areaStats = {};\n  intersectionArea(interior, areaStats);\n\n  if (areaStats.arcs.length === 0) {\n    return { x: 0, y: -1000, disjoint: true };\n  }\n  if (areaStats.arcs.length == 1) {\n    return { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };\n  }\n  if (exterior.length) {\n    // try again without other circles\n    return computeTextCentre(interior, []);\n  }\n  // take average of all the points in the intersection\n  // polygon. this should basically never happen\n  // and has some issues:\n  // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n  return getCenter(areaStats.arcs.map((a) => a.p1));\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n  const ret = {};\n  const circleids = Object.keys(circles);\n  for (const circleid of circleids) {\n    ret[circleid] = [];\n  }\n  for (let i = 0; i < circleids.length; i++) {\n    const ci = circleids[i];\n    const a = circles[ci];\n    for (let j = i + 1; j < circleids.length; ++j) {\n      const cj = circleids[j];\n      const b = circles[cj];\n      const d = distance(a, b);\n\n      if (d + b.radius <= a.radius + 1e-10) {\n        ret[cj].push(ci);\n      } else if (d + a.radius <= b.radius + 1e-10) {\n        ret[ci].push(cj);\n      }\n    }\n  }\n  return ret;\n}\n\nfunction computeTextCentres(circles, areas, symmetricalTextCentre) {\n  const ret = {};\n  const overlapped = getOverlappingCircles(circles);\n  for (let i = 0; i < areas.length; ++i) {\n    const area = areas[i].sets;\n    const areaids = {};\n    const exclude = {};\n\n    for (let j = 0; j < area.length; ++j) {\n      areaids[area[j]] = true;\n      const overlaps = overlapped[area[j]];\n      // keep track of any circles that overlap this area,\n      // and don't consider for purposes of computing the text\n      // centre\n      for (let k = 0; k < overlaps.length; ++k) {\n        exclude[overlaps[k]] = true;\n      }\n    }\n\n    const interior = [];\n    const exterior = [];\n    for (let setid in circles) {\n      if (setid in areaids) {\n        interior.push(circles[setid]);\n      } else if (!(setid in exclude)) {\n        exterior.push(circles[setid]);\n      }\n    }\n    const centre = computeTextCentre(interior, exterior, symmetricalTextCentre);\n    ret[area] = centre;\n    if (centre.disjoint && areas[i].size > 0) {\n      console.log('WARNING: area ' + area + ' not represented on screen');\n    }\n  }\n  return ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n  // figure out sets that are completely overlapped by relativeTo\n  const overlaps = getOverlappingCircles(div.selectAll('svg').datum());\n  const exclude = new Set();\n  for (const check of relativeTo.sets) {\n    for (let setid in overlaps) {\n      const overlap = overlaps[setid];\n      for (let j = 0; j < overlap.length; ++j) {\n        if (overlap[j] == check) {\n          exclude.add(setid);\n          break;\n        }\n      }\n    }\n  }\n\n  // checks that all sets are in exclude;\n  function shouldExclude(sets) {\n    return sets.every((set) => !exclude.has(set));\n  }\n\n  // need to sort div's so that Z order is correct\n  div.selectAll('g').sort((a, b) => {\n    // highest order set intersections first\n    if (a.sets.length != b.sets.length) {\n      return a.sets.length - b.sets.length;\n    }\n\n    if (a == relativeTo) {\n      return shouldExclude(b.sets) ? -1 : 1;\n    }\n    if (b == relativeTo) {\n      return shouldExclude(a.sets) ? 1 : -1;\n    }\n\n    // finally by size\n    return b.size - a.size;\n  });\n}\n\n/**\n * @param {number} x\n * @param {number} y\n * @param {number} r\n * @returns {string}\n */\nfunction circlePath(x, y, r) {\n  const ret = [];\n  ret.push('\\nM', x, y);\n  ret.push('\\nm', -r, 0);\n  ret.push('\\na', r, r, 0, 1, 0, r * 2, 0);\n  ret.push('\\na', r, r, 0, 1, 0, -r * 2, 0);\n  return ret.join(' ');\n}\n\n/**\n * inverse of the circlePath function, returns a circle object from an svg path\n * @param {string} path\n * @returns {{x: number, y: number, radius: number}}\n */\nfunction circleFromPath(path) {\n  const tokens = path.split(' ');\n  return { x: Number.parseFloat(tokens[1]), y: Number.parseFloat(tokens[2]), radius: -Number.parseFloat(tokens[4]) };\n}\n\nfunction intersectionAreaArcs(circles) {\n  if (circles.length === 0) {\n    return [];\n  }\n  const stats = {};\n  intersectionArea(circles, stats);\n  return stats.arcs;\n}\n\nfunction arcsToPath(arcs, round) {\n  if (arcs.length === 0) {\n    return 'M 0 0';\n  }\n  const rFactor = Math.pow(10, round || 0);\n  const r = round != null ? (v) => Math.round(v * rFactor) / rFactor : (v) => v;\n  if (arcs.length == 1) {\n    const circle = arcs[0].circle;\n    return circlePath(r(circle.x), r(circle.y), r(circle.radius));\n  }\n  // draw path around arcs\n  const ret = ['\\nM', r(arcs[0].p2.x), r(arcs[0].p2.y)];\n  for (const arc of arcs) {\n    const radius = r(arc.circle.radius);\n    ret.push('\\nA', radius, radius, 0, arc.large ? 1 : 0, arc.sweep ? 1 : 0, r(arc.p1.x), r(arc.p1.y));\n  }\n  return ret.join(' ');\n}\n\n/**\n * returns a svg path of the intersection area of a bunch of circles\n * @param {ReadonlyArray<{x: number, y: number, radius: number}>} circles\n * @returns {string}\n */\nfunction intersectionAreaPath(circles, round) {\n  return arcsToPath(intersectionAreaArcs(circles), round);\n}\n\nfunction layout(data, options = {}) {\n  const {\n    lossFunction: loss,\n    layoutFunction: layout = venn,\n    normalize = true,\n    orientation = Math.PI / 2,\n    orientationOrder,\n    width = 600,\n    height = 350,\n    padding = 15,\n    scaleToFit = false,\n    symmetricalTextCentre = false,\n    distinct,\n    round = 2,\n  } = options;\n\n  let solution = layout(data, {\n    lossFunction: loss === 'default' || !loss ? lossFunction : loss === 'logRatio' ? logRatioLossFunction : loss,\n    distinct,\n  });\n\n  if (normalize) {\n    solution = normalizeSolution(solution, orientation, orientationOrder);\n  }\n\n  const circles = scaleSolution(solution, width, height, padding, scaleToFit);\n  const textCentres = computeTextCentres(circles, data, symmetricalTextCentre);\n\n  const circleLookup = new Map(\n    Object.keys(circles).map((set) => [\n      set,\n      {\n        set,\n        x: circles[set].x,\n        y: circles[set].y,\n        radius: circles[set].radius,\n      },\n    ])\n  );\n  const helpers = data.map((area) => {\n    const circles = area.sets.map((s) => circleLookup.get(s));\n    const arcs = intersectionAreaArcs(circles);\n    const path = arcsToPath(arcs, round);\n    return { circles, arcs, path, area, has: new Set(area.sets) };\n  });\n\n  function genDistinctPath(sets) {\n    let r = '';\n    for (const e of helpers) {\n      if (e.has.size > sets.length && sets.every((s) => e.has.has(s))) {\n        r += ' ' + e.path;\n      }\n    }\n    return r;\n  }\n\n  return helpers.map(({ circles, arcs, path, area }) => {\n    return {\n      data: area,\n      text: textCentres[area.sets],\n      circles,\n      arcs,\n      path,\n      distinctPath: path + genDistinctPath(area.sets),\n    };\n  });\n}\n\nexport { VennDiagram, bestInitialLayout, circleArea, circleCircleIntersection, circleFromPath, circleOverlap, circlePath, computeTextCentre, computeTextCentres, disjointCluster, distance, distanceFromIntersectArea, greedyLayout, intersectionArea, intersectionAreaPath, layout, logRatioLossFunction, lossFunction, normalizeSolution, scaleSolution, sortAreas, venn, wrapText };\n",null,null,null,null],"names":["isEllipse","d","rx","dist","a","b","x","cx","y","cy","Math","sqrt","DEG2RAD","PI","pointAtCircle","radius","angle","cos","sin","ArcSlice","Element","[object Object]","mouseX","mouseY","props","this","getProps","usedSets","Set","sets","checkRef","p","ref","inside","rotation","ry","r","arc","arcs","refs","Number","isNaN","delete","mode","remaining","Array","from","i","length","inRange","NaN","text","getCenterPoint","ctx","save","options","path","beginPath","window","Path2D","jest","s","x1","y1","map","rot","large","sweep","x2","y2","join","generateArcSlicePath","moveTo","ellipse","backgroundColor","fillStyle","fill","borderColor","strokeStyle","lineWidth","borderWidth","stroke","restore","BarElement","defaults","patchController","type","config","controller","elements","scales","registry","addControllers","isArray","addElements","addScales","c","VennDiagramController","DatasetController","super","initialize","enableOptionSharing","update","slices","_cachedMeta","data","updateElements","size","bb","lookup","venn0","venn1","venn2","venn3","venn4","venn5","min","f","width","height","mx","v","my","intersections","layout","log2","start","count","xScale","yScale","w","right","left","h","bottom","top","l","computeLayout","_layout","_layoutFont","_resolveTickFontOptions","color","ticks","firstOpts","resolveDataElementOptions","sharedOptions","getSharedOptions","includeOptions","slice","properties","updateElement","updateSharedOptions","meta","chart","forEach","elem","draw","font","textBaseline","string","labels","set","textAlign","align","verticalAlign","fillText","values","getDataset","intersection","value","toLocaleString","dataElementType","id","plugins","tooltip","callbacks","title","item","datasets","datasetIndex","dataIndex","max","display","VennDiagramChart","Chart","LinearScale","exports","bisect","parameters","maxIterations","tolerance","fA","fB","delta","mid","fMid","abs","zeros","zerosM","dot","ret","norm2","scale","weightedSum","w1","v1","w2","v2","j","nelderMead","x0","maxDiff","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","N","simplex","fx","point","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","history","sortedSimplex","state","push","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","temp","yk","alpha","delta_k","gradientDescent","learnRate","gradientDescentLineSearch","functionCalls","inner","factory","SMALL","intersectionArea","circles","stats","intersectionPoints","intersect","circleCircleIntersection","parentIndex","getIntersectionPoints","innerPoints","filter","every","circle","distance","containedInCircles","arcArea","polygonArea","center","getCenter","atan2","p2","p1","midPoint","includes","a1","a2","angleDiff","circleArea","smallest","disjoint","area","acos","circleOverlap","r1","r2","y0","points","venn","initialLayout","bestInitialLayout","loss","lossFunction","areas","distinct","Object","assign","toKey","arr","Map","si","String","get","sj","k1","k2","ids","pairs","add","has","addMissingAreas","setids","keys","setid","positions","SMALL$1","distanceFromIntersectArea","overlap","setOverlaps","rowid","weight","mostOverlapped","positioned","isPositioned","element","positionSet","index","setIndex","d1","k","d2","extraPoints","bestLoss","bestPoint","localLoss","greedyLayout","constrained","restarts","distances","constraints","getDistanceMatrices","norm","row","obj","xi","yi","xj","yj","dij","constraint","squaredDistance","constrainedMDSGradient","best","random","constrainedMDSLayout","overlaps","output","logRatioLossFunction","differenceFromIdeal","log","orientateCircles","orientation","orientationOrder","largestX","largestY","slope","getBoundingBox","minMax","reduce","acc","NEGATIVE_INFINITY","POSITIVE_INFINITY","xRange","yRange","normalizeSolution","solution","fromObjectNotation","clusters","find","parent","union","xRoot","yRoot","maxDistance","disjointClusters","disjointCluster","cluster","bounds","returnBounds","spacing","addCluster","xOffset","yOffset","centreing","toObjectNotation","circleMargin","interior","exterior","margin","m","computeTextCentre","symmetricalTextCentre","valid","e","areaStats","computeTextCentres","overlapped","circleids","circleid","ci","cj","getOverlappingCircles","areaids","exclude","centre","console","layoutFunction","normalize","padding","scaleToFit","round","xScaling","yScaling","toScaleDiameter","scaling","scaleSolution","textCentres","circleLookup","helpers","intersectionAreaArcs","rFactor","pow","circlePath","arcsToPath","genDistinctPath","distinctPath","shiftPath","mapX","parseFloat","toString","mapY","split","line","parts","trim","euler","singleSets","setNames","setCircles","eulerCenter","sumX","sumY","setData","angleAtCircle","asArc","findIndex","subSets","subSet","indexOf","EulerDiagramController","_data","EulerDiagramChart","generateSubset","members","notMembers","label","others","not","o","degree","base"],"mappings":"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"}